from typing import Protocol, List, Dict, Any, Optional
from rich.console import Console

console = Console()

class IntentTemplatePort(Protocol):
    """Port for generating Intent Templates."""
    
    def generate(self, intent_data: List[Dict[str, Any]]) -> str:
        """Generates the formatted intent string from data."""
        ...

class MarkdownIntentAdapter(IntentTemplatePort):
    """Generates a Markdown formatted Intent Template."""
    
    def generate(self, intent_data: List[Dict[str, Any]]) -> str:
        """
        Generates a Markdown intent report from hierarchical data.
        
        Structure:
        - Project Header
        - Module Summary
        - Detailed Module Content (Interface -> Implementation)
        """
        lines = []
        
        # 1. Header
        lines.append("# Intent Map")
        lines.append(f"> Auto-generated by CMM Parser")
        lines.append("")
        
        # 2. Module Summary
        lines.append("## Module Summary")
        for module in intent_data:
            doc = self._get_first_line(module.get("docstring", ""))
            lines.append(f"* **{module['name']}**: {doc}")
        lines.append("")
        lines.append("---")
        lines.append("")
        
        # 3. Detailed Content
        for module in intent_data:
            lines.append(f"## Module: `{module['name']}`")
            if module.get("docstring"):
                lines.append(f"_{module['docstring']}_")
            lines.append("")
            
            # Interface Layer (The "What")
            lines.append("### Interface Layer (The 'What')")
            
            children = module.get("children", [])
            public_contracts = [c for c in children if c.get("visibility") == "public"]
            
            if not public_contracts:
                lines.append("_No public contracts detected._")
            
            for entity in public_contracts:
                self._render_entity(lines, entity)
                
            lines.append("")
            lines.append("---")
            lines.append("")

        return "\n".join(lines)

    def _render_entity(self, lines: List[str], entity: Dict[str, Any], depth: int = 0):
        """Recursively render an entity and its relations."""
        name = entity.get("name")
        etype = entity.get("type", "unknown")
        doc = entity.get("docstring", "")
        type_hint = entity.get("type_hint")
        
        # Format Name
        display_name = f"**{name}**"
        if type_hint:
             display_name += f" `{type_hint}`"
        
        prefix = "* " if depth == 0 else "    " * depth + "* "
        
        # Main Line
        lines.append(f"{prefix}{display_name}")
        
        # Docstring
        if doc:
            doc_lines = doc.split('\n')
            clean_doc = doc_lines[0].strip() if doc_lines else ""
            if clean_doc:
                lines.append(f"{prefix}  > {clean_doc}")
                
        # Implementation Depth (The "How" - Verified Relations)
        relations = entity.get("relations", [])
        verified_calls = [r for r in relations if r.get("is_verified")]
        
        if verified_calls:
            rel_prefix = "    " * (depth + 1) + "* "
            lines.append(f"{rel_prefix}_Implementation Details_:")
            for rel in verified_calls:
                 lines.append(f"{rel_prefix}  -> Calls `{rel['to_name']}` (Verified)")

        # Children (Methods/Nested classes)
        # Note: In the query logic, we need to ensure 'children' are populated correctly
        # The current 'children' list we passed in public_contracts might be flat or nested depending on query
        # Assuming the generic 'children' key exists
        children = entity.get("children", [])
        for child in children:
            self._render_entity(lines, child, depth + 1)

    def _get_first_line(self, text: Optional[str]) -> str:
        if not text:
            return ""
        return text.split('\n')[0].strip()
